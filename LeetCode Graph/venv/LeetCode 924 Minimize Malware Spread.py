class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        def dfs(node, see):
            for i in range(len(graph[node])):
                if graph[node][i] == 1 and i not in see:
                    see.add(i)
                    dfs(i, see)
        res = min(initial)
        initial = set(initial)
        seen = set()
        mincount = 0
        for i in range(len(graph)):
            if i not in seen:
                see = set([i])
                dfs(i, see)
                infected = see & initial
                if len(infected) == 1:
                    if len(see) > mincount or (len(see) == mincount and list(infected)[0] < res):
                        res = list(infected)[0]
                        mincount = len(see)
            seen |= see
        return res

#DFS
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        self.parent = [i for i in range(len(graph))]
        self.rank = [1 for _ in range(len(graph))]
        for i in range(len(graph)):
            for j in range(i + 1, len(graph)):
                if graph[i][j] == 1:
                    self.union(i, j)
        print(self.rank)
        dic = collections.defaultdict(list)
        for i, e in enumerate(self.parent):
            dic[e].append(i)
        res = min(initial)
        initial = set(initial)
        mincount = 0
        for node in dic:
            seen = set()
            for n in dic[node]:
                if n in initial:
                    seen.add(n)
            if len(seen) == 1:
                if len(dic[node]) > mincount or (len(dic[node]) == mincount and list(seen)[0] < res):
                    res = list(seen)[0]
                    mincount = len(dic[node])
        return res

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        px = self.find(x)
        py = self.find(y)
        if px == py:
            return
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.rank[px] += self.rank[py]
        self.parent[py] = px
#Union fink (use rank)